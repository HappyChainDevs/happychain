import{r as d}from"./components-BLd368Cb.js";const _="2.14.1",y=()=>`@wagmi/core@${_}`;var w=function(e,n,t,s){if(t==="a"&&!s)throw new TypeError("Private accessor was defined without a getter");if(typeof n=="function"?e!==n||!s:!n.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?s:t==="a"?s.call(e):s?s.value:n.get(e)},m,b;let E=class g extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return y()}constructor(n,t={}){super(),m.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const s=t.cause instanceof g?t.cause.details:t.cause?.message?t.cause.message:t.details,c=t.cause instanceof g&&t.cause.docsPath||t.docsPath;this.message=[n||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...c?[`Docs: ${this.docsBaseUrl}${c}.html${t.docsSlug?`#${t.docsSlug}`:""}`]:[],...s?[`Details: ${s}`]:[],`Version: ${this.version}`].join(`
`),t.cause&&(this.cause=t.cause),this.details=s,this.docsPath=c,this.metaMessages=t.metaMessages,this.shortMessage=n}walk(n){return w(this,m,"m",b).call(this,this,n)}};m=new WeakSet,b=function e(n,t){return t?.(n)?n:n.cause?w(this,m,"m",e).call(this,n.cause,t):n};let v=!1;async function M(e,n={}){if(v)return[];v=!0,e.setState(r=>({...r,status:r.current?"reconnecting":"connecting"}));const t=[];if(n.connectors?.length)for(const r of n.connectors){let a;typeof r=="function"?a=e._internal.connectors.setup(r):a=r,t.push(a)}else t.push(...e.connectors);let s;try{s=await e.storage?.getItem("recentConnectorId")}catch{}const c={};for(const[,r]of e.state.connections)c[r.connector.id]=1;s&&(c[s]=0);const u=Object.keys(c).length>0?[...t].sort((r,a)=>(c[r.id]??10)-(c[a.id]??10)):t;let o=!1;const f=[],i=[];for(const r of u){const a=await r.getProvider().catch(()=>{});if(!a||i.some(h=>h===a)||!await r.isAuthorized())continue;const l=await r.connect({isReconnecting:!0}).catch(()=>null);l&&(r.emitter.off("connect",e._internal.events.connect),r.emitter.on("change",e._internal.events.change),r.emitter.on("disconnect",e._internal.events.disconnect),e.setState(h=>{const P=new Map(o?h.connections:new Map).set(r.uid,{accounts:l.accounts,chainId:l.chainId,connector:r});return{...h,current:o?h.current:r.uid,connections:P}}),f.push({accounts:l.accounts,chainId:l.chainId,connector:r}),i.push(a),o=!0)}return(e.state.status==="reconnecting"||e.state.status==="connecting")&&(o?e.setState(r=>({...r,status:"connected"})):e.setState(r=>({...r,connections:new Map,current:null,status:"disconnected"}))),v=!1,f}function S(e,n){const{initialState:t,reconnectOnMount:s}=n;return t&&!e._internal.store.persist.hasHydrated()&&e.setState({...t,chainId:e.chains.some(c=>c.id===t.chainId)?t.chainId:e.chains[0].id,connections:s?t.connections:new Map,status:s?"reconnecting":"disconnected"}),{async onMount(){e._internal.ssr&&(await e._internal.store.persist.rehydrate(),e._internal.mipd&&e._internal.connectors.setState(c=>{const u=new Set;for(const i of c??[])i.rdns&&u.add(i.rdns);const o=[],f=e._internal.mipd?.getProviders()??[];for(const i of f){if(u.has(i.info.rdns))continue;const r=e._internal.connectors.providerDetailToConnector(i),a=e._internal.connectors.setup(r);o.push(a)}return[...c,...o]})),s?M(e):e.storage&&e.setState(c=>({...c,connections:new Map}))}}}function C(e){const{children:n,config:t,initialState:s,reconnectOnMount:c=!0}=e,{onMount:u}=S(t,{initialState:s,reconnectOnMount:c});t._internal.ssr||u();const o=d.useRef(!0);return d.useEffect(()=>{if(o.current&&t._internal.ssr)return u(),()=>{o.current=!1}},[]),n}const p=d.createContext(void 0);function x(e){const{children:n,config:t}=e,s={value:t};return d.createElement(C,e,d.createElement(p.Provider,s,n))}const $="2.12.25",j=()=>`wagmi@${$}`;class B extends E{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/react"}get version(){return j()}}class I extends B{constructor(){super("`useConfig` must be used within `WagmiProvider`.",{docsPath:"/api/WagmiProvider"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiProviderNotFoundError"})}}function F(e={}){const n=e.config??d.useContext(p);if(!n)throw new I;return n}export{E as B,x as W,F as u,_ as v};
